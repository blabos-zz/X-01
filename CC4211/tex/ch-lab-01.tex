\chapter{Lab 01 - Chamadas de Sistema (System Calls)}

As Chamadas de Sistema são o conjunto de funções que compõe a interface entre o sistema operacional e os programas de usuário. Elas permitem o acesso a recursos e dispositivos da máquina através de uma API padronizada, de forma que o programador não precise se preocupar com detalhes do hardware.

Essa API permite acesso aos recursos internos do SO, de forma que se por um lado ela é essencial para o desenvolvimento de aplicações de baixo nível, por outro seu uso indevido pode ser potencialmente danoso ao sistema inteiro \cite{Mitchell}

\section{Objetivos}

O objetivo deste laboratório é familiarizar o aluno com o uso de algumas chamadas de sistema simples, como getpid, read, write, etc.

Utilizaremos para isso alguns exemplos de códigos escritos em linguagem C.

\section{Exemplos de Chamadas de Sistema}

\subsection{getpid}

\begin{verbatim}
pid_t getpid(void);
\end{verbatim}

A chamada getpid retorna o id do processo corrente (pid - process ID)\cite{Man}. Um pid é uma estrutura de dados arbitrária que alguns sistemas operacionais utilizam para identificar unicamente um processo. No Unix o pid é um número inteiro sem sinal.

Para obtermos o pid do processo atual utilizando linguagem C podemos compilar e executar o código abaixo:

\newpage

\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// getpid.c
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    printf("Current process ID: %d\n", getpid());
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

Salve este código em um arquivo chamado getpid.c, compile-o e execute-o com os comandos:

\begin{espacosimples}
\begin{verbatim}
gcc -o getpid getpid.c
./getpid
Current process ID: 8015
./getpid
Current process ID: 8017
\end{verbatim}
\end{espacosimples}

Note que a cada execução, o pid muda. Isso acontece porque a cada nova execução, é criado um novo processo com um novo e exclusivo pid.

\subsection{nanosleep}

\begin{verbatim}
int nanosleep(const struct timespec *req, struct timespec *rem);
\end{verbatim}

A chamada nanosleep suspende a execução da thread atual até que se passe o tempo indicado pelos parâmetros\cite{Man}. A thread literalmente dorme por um período determinado. Vamos ao código:

\newpage

\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// nanosleep.c
#include <time.h>
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    struct timespec tv;
    tv.tv_sec  = (time_t)(2);           // Configurando timer para 2
    tv.tv_nsec = (long)(0.5 * 1e+9);    // segundos e meio
    
    printf("0.0 sec\n");
    nanosleep(&tv, &tv);
    printf("2.5 sec\n");
    
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

Novamente salve o código em um arquivo chamado nanosleep.c, compile e execute com:

\begin{espacosimples}
\begin{verbatim}
gcc -o nanosleep nanosleep.c
./nanosleep
0.0 sec
2.5 sec
\end{verbatim}
\end{espacosimples}

Ele mostra o texto \texttt{ 0.0 sec}, aguarda dois segundos e meio, mostra o texto \texttt{ 2.5 sec} e então encerra.

A chamada nanosleep é utilizada para a criação de timers de alta resolução e possui mais algumas capacidades que não serão exploradas no momento, como a habilidade de retornar o tempo que falta até o timer acabar, caso ela seja interrompida antes do planejado.

\subsection{kill}

\begin{verbatim}
int kill(pid_t pid, int sig);
\end{verbatim}

A chamada kill é utilizada para enviar sinais a qualquer processo\cite{Man}. Um sinal é uma forma de comunicação entre o kernel e os processos e entre processos, uma ``espécie de mensagem''. Dentre esses sinais estão comandos para que o processo espere, continue a sua execução ou termine, por exemplo.

Neste exercício vamos utilizar as chamadas anteriores para um processo que executa um laço infinito e então vamos criar um programa que força a finalização do outro processo com uma chamada kill.

No primeiro programa, \emph{loop}, usamos getpid para capturar o pid do processo. Em seguida, fazemos um while infinito mostrando uma mensagem na tela a cada 5 segundos. A pausa é feita utilizanod a chamada nanosleep.

No segundo programa, \emph{terminator}, capturamos o pid do processo que está em loop passado como argumento, e então enviamos o sinal \emph{SIGTERM}, que significa o programa que o recebeu deve terminar imediatamente.

Veja os códigos abaixo:

\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// loop.c
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    struct timespec tv;
    tv.tv_sec  = (time_t)(5);           // Configurando timer para 5
    tv.tv_nsec = (long)(0);             // segundos
    
    printf("Current process ID: %d\n", getpid());
    
    while (1) {
        printf("Aguardando 5 sec\n");
        nanosleep(&tv, &tv);
    }
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

\newpage

\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// terminator.c
#include <sys/types.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char** argv) {
    pid_t pid_to_kill;
    
    if (argc < 2) {
        printf("Preciso de um pid para exterminar\n");
        return EXIT_FAILURE;
    }
    
    pid_to_kill = (pid_t)abs(atoi(argv[1]));
    
    printf("Hasta la vista %d\n", pid_to_kill);
    kill(pid_to_kill, SIGTERM);
    
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

Salve os arquivos com os nomes indicados e compile-os com os comandos:

\begin{espacosimples}
\begin{verbatim}
gcc -o loop loop.c
gcc -o terminator teminator.c
\end{verbatim}
\end{espacosimples}

Para realizar a experiência, vamos executar o programa loop em segundo plano. Em Unix isso é feito acrescentando um \& logo após o nome do programa ao invocá-lo. Não se preocupe com isso agora, esse truque é apenas para que tenhamos acesso novamente ao terminal, já que o programa em loop não termina e precisamos executar outro programa.

\begin{espacosimples}
\begin{verbatim}
./loop &
Current process ID: 10515
Aguardando 5 sec
[1] 10515
Aguardando 5 sec
Aguardando 5 sec
Aguardando 5 sec
...
\end{verbatim}
\end{espacosimples}

Depois de invocado, o programa loop vai mostrar o seu pid e a cada 5 segundos vai escrever uma mensagem na tela. Para encerrá-lo, vamos invocar o programa terminator e passar o pid do loop como parâmetro, de forma que o terminator possa encontrar o processo loop e enviar-lhe um sinal (SIGTERM).

\begin{espacosimples}
\begin{verbatim}
...
Aguardando 5 sec
./terminator 10515
Hasta la vista 10515
[1]+  Finalizado              ./loop
\end{verbatim}
\end{espacosimples}

\subsection{read e write}

\begin{espacosimples}
\begin{verbatim}
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
\end{verbatim}
\end{espacosimples}

As funções read e write são duas das chamadas de função capazes de acessar dispositivos de entrada e saída.

Enquanto a função read é capaz de ler dados de um determinado dispositivo, a sua contraparte write é capaz de gravar dados em dispositivos.

Podemos demonstrar o seu uso básico com um programa bem simples que captura a entrada do teclado e a imprime na tela:

\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// read_write.c
#include <unistd.h>
#include <stdlib.h>

#define BUFFSIZE    1024
#define STDIN       0
#define STDOUT      1
#define STDERR      2

int main(void){
    char buffer[BUFFSIZE];
    int read_chars = 0;

    while((read_chars = read(STDIN, buffer, BUFFSIZE)) > 0) {
        write(STDOUT, buffer, read_chars);
    }
    
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

Salve com o nome indicado, compile e execute com:

\begin{espacosimples}
\begin{verbatim}
gcc -o read_write read_write.c
./read_write
\end{verbatim}
\end{espacosimples}

O programa vai ficar esperando que você digite algum texto no teclado. Ao pressionar ENTER, o texto é capturado da entrada padrão pela chamada read e impresso na saída padrão pela chamada write.

\section{Conclusão}

As chamadas de sistema fornecem uma forma simples de acessar recursos e dispositivos do sistema como timers, sinais, teclado, vídeo, entre outros. entretanto devem ser utilizadas com cautela pos podem até mesmo forçar o encerramento de um outro processo.

Em geral, em uma camada acima das chamadas de sistema são construídas bibliotecas que encapsulam as funcionalidades, adicionando facilidades e/ou mecanismos de controle para um acesso ainda mais simples e seguro.