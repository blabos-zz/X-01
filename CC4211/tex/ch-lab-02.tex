\chapter{Lab 02 - Minishell}

Um shell (casca, concha) um programa que executa acima do sistema operacional, responsável por criar a interface entre o usuário e a máquina.

O shell deve receber as interações do usuário e transformar essas acões em algo compreensível para o computador. Analogamente ele precisa receber as respostas do kernel e traduzir isso para uma linguagem compreensível para humanos.

O shell também deve ser capaz de disparar a execução dos programs de usuário conforme forem requisitados.

\section{Objetivos}

Neste laboratório vamos mostrar como consntruir um minishell bem simples utilizando somente chamadas de sistema. Vamos apresentar também algumas chamdas novas, capazes de executar programas externos.

\section{Requisitos}

O nosso minishel fará a interface entre o usuário e a máquina. Para isso ele precisará fornecer mecanismos para que o usuário possa requisitar algo e receber ma resposta, que pode ser uma requisição bem sucedida ou não.

Para que o usuário possa interagir com a máquina, forneceremos o acesso ao teclado, dessa forma nosso minishell precisará ler dados do teclado. Já sabemos como fazer isso utilizando a chamada read.

Analogamente para que o usuário obtenha uma resposta, precisamos ser capazes de mostrar uma mensagem na tela. Para isso utilizaremos a chamada write.

O próximo requisito é que o minishell seja capaz de executar comandos digitados pelo usuário.

Para cumprir esse requisito nosso minishel precisa ser capaz de fazer duas coisas: a primeira é criar um novo processo e a segunda é utilizar esse processo para executar um novo programa.

Apresentamos então as chamadas \emph{fork} e \emph{execve}.

A chamada fork cria uma cópia do processo atual, ou seja, um novo processo a partir do processo corrente. O novo processo é chamado processo-filho (child) do processo que o originou, enquanto que o processo original é chamado de pai (parent). Eles mantem alguams relações interessantes entre si, mas não abordaremos aqui.

Para que o novo processo recém-criado seja capaz de executar um programa externo, a chamada execve substitui a imagem do processo (código e dados) pela imagem de um programa especificado.

O nosso minishel deverá então ser capaz de criar um novo processo e substituir esse processo por um programa externo qualquer.

\section{Implementação}

Conforme a sofisticação das aplicações vão aumentando, torna-se cada vez mais trabalhoso trabalhar diretamente com as chamadas de sistema. Por isso que foram criadas as bibliotecas de mais lato nível.

Para começar, temos que definir na mão labels para tamanho máximo de buffer, stdin, stdout, entre outros. Mostrar algo mais elaborado na tela também vai ficando complicado.

Toda vez que lemos algo do teclado, precisamos estar atentos ao fato de que o último caracter digitado foi o ENTER, logo ele sempre estará no final do buffer. precisamos removê-lo pois senão a função excve não vai encontrar os comandos que digitarmos e portanto não vai conseguir executá-los.

Vamos então analisar com calma o código abaixo:

\newpage
\begin{espacosimples}
\begin{verbatim}
//--------------------------------------------------------------------
// minishell.c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>

#define BUFFSIZE    1024
#define STDIN       0
#define STDOUT      1
#define STDERR      2

int main(int argc, char** argv) {
    char buffer[BUFFSIZE];
    pid_t pid;
    int status, read_chars;
    
    while (1) {
        // prompt
        write(STDOUT, "% ", 2);
        
        if ((read_chars = read(STDIN, buffer, BUFFSIZE)) <= 0) break;
        
        buffer[--read_chars] = '\0';
        if (!read_chars) continue;
        
        if((pid = fork()) < 0) {
            write(STDERR, "fork error\n", 11);
        }
        else if (pid == 0){
            // Child
            execve(buffer, NULL, NULL);
            write(STDERR, "couldn't execute: ", 18);
            write(STDERR, buffer, read_chars);
            write(STDERR, "\n", 1);
            return 127;
        }
        
        // parent
        if((pid = waitpid(pid, &status, 0)) < 0) {
            write(STDERR, "waitpid error\n", 14);
        }
    }
    
    write(STDOUT, "\n", 1);
    return EXIT_SUCCESS;
}
//--------------------------------------------------------------------
\end{verbatim}
\end{espacosimples}

Nas primeiras linhas, fazemos includes dos headers que vamos utilizar e criamos alguns labels para referenciar stdin, stdout, etc.

Dentro do main, declaramos algumas variáveis e inciamos o loop principal do minishel. Esse loop se encerra na ocorrência de algum erro ou quando o usuário digitar Ctrl+D no teclado.

Em seguida escrevemos na tela o prompt (sinal \%{}) e esperamos dados da entrada padrão. quando o usuário entra com algum texto e tecla ENTER, a chamada read coloca esse texto no buffer e então limpamos o ENTER do último caracter simplesmente sobrescrevendo-o com o caracter nulo (terminador de string).

Agora nosso buffer está pronto e podemos partir para a execução do fork.

Conforme comentamos anteriormente, a chamada fork cria uma cópia do processo atual. ela é invocada no processo pai uma única vez, mas por causa da duplicação dos processos, ela retorna duas vezes! Ela retorna no processo pai \textbf{E} retorna também no processo filho. A diferença é que quando ela retorna no processo pai, seu valor de retorno é o pid do processo recém-criado, enquanto que ao retornar no processo filho, seu valor de retorno é zero.

Utilizamos essa informação para executar diferentes rotinas depois do fork, dependendo se estivermos no processo pai ou no processo filho.

Quando estivermos no processo filho devemos tentar executar o comando externo que foi passado para o buffer. Isso é feito através da chamada execve, que tenta interpretar o buffer como o caminho completo para um programa. Se ela conseguir localizar o programa, ela substitui a imagem do processo corrente (filho) pela imagem do programa encontrado, o comando que digitamos no prompt do minishell. A partir daí o programa externo começa sua execução tomando o lugar do processo filho.

Note que a partir do momento em que a execve foi executada com sucesso, nada do processo filho existe mais, nem dados, nem código, apenas a ``casca'' do processo criado pelo sistema operacional permanece, para que o novo programa execute. Portanto, a execve nunca retorna, pois ela não existe mais. Se a execve retornar, significa que ela falhou em substituir a imagem do processo atual pela imagem do programa externo.

Analogamente, quando no processo pai, executamos ações distintas. No processo pai, esperamos o processo filho encerrar para que os recursos alocados por ele pssam ser liberados. Para isso utilizamos outra chamada de sistema, a \emph{waitpid}.

A chamada waitpid faz com que o processo atual aguarde uma alteração no estado do processo filho, que geralmente (mas não necessariamente) é o processo terminar.

Se tudo ocorreu satisfatoriamente, recomeçamos o loop aguardando um novo comando do usuário.

Note também que nosso minishell só consegue executar comandos quando passamos o caminho completo para eles. A execve não tenta procurá-los em variáveis de ambiente ou diretórios padrão, ela simplesmente tenta executar exatamente o que passamos para ela. Chamadas de sistema tem essa característica de serem o mais diretas possível. As facilidades e comodidades devem ser implementadas pelas bibliotecas de mais alto nível, como a libc por exemplo.

Em nosso próximo projeto vamos adicionar um pouco mais de comodidade ao usuário, utilizando funções da libc.

\section{Conclusão}

Utilizando apenas chamadas de sistema fomos capzaes de implementar um pequeno shell bastante simples. Entretanto já começamos a nos defrontar com dificuldades geradas pela necessidade de sofisticação da aplicação enquanto que as chamadas de sistema fornecem apenas funcionalidades mais cruas.

Após esse projeto, o aluno deverá ser capaz de entender o básico do funcionamento de um shell, bem como das chamadas fork, execve e waitpid.